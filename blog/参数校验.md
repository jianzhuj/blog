#### JSR303规范

jsr303规范定义了一系列参数校验的规范

```
@Controller
@Validated
public class TestController {
    @PostMapping("/test1")
    public String test1( @Valid Student student,BindingResult bindingResult){
        return student.getName();
    }
}
```

hibernate实现并拓展了这些规范

```
    <dependency>
            <groupId>javax.validation</groupId>
            <artifactId>validation-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
        </dependency>
```

#### SpringBoot参数校验

##### 		单个值校验

```
/**
 * @author ekko
 */
@RestController
@Validated
public class TestController {
    @GetMapping("/test2")
    public String test2( @RequestParam @Max(value = 10,message = "最小值为10") Integer age){
        return age.toString();
    }
}

http://localhost:8080/test2?age=100  
会抛出一个校验失败的异常
```



##### 		实体对象校验

```
@Controller
public class TestController {
    @PostMapping("/test1")
    public String test1( @RequestBody @Validated Student student){

        return student.getName();
    }
}

```



##### 		嵌套校验

​			a对象中有b对象,则需要在A类中的b字段上加上@valid注解,只有@valid注解才能嵌套校验,

```
public class Student {

    @NotBlank(message = "不允许为空")
    private String name ;
    private String age ;

    @NotEmpty(message = "不允许为空1")
    @Valid
    private List<Score> scoreList;
    }
    
    
    public class Score {
    @NotBlank(message = "不允许为空2")
    public String name ;
    @NotBlank(message = "不允许为空3")
    public String value ;
    }
    
    
    public class TestController {
    @PostMapping("/test1")
    public String test1( @RequestBody @Validated Student student){

        return student.getName();
    }


}

    
    
```

​	

##### 		分组校验

​		可能新增和编辑的时候,针对同一个VO对象的校验规则不同,这个时候需要分组校验来实现

  1. 新增若干个类或者接口

  2. 在具体的校验条件上加上group参数,指定校验条件生效的组

  3. 在接口上@Validated({GroupA.class}) Student student  加上指定校验哪些组的校验项

     ```
     @Controller
     @Validated
     @RestController
     public class TestController {
         @PostMapping("/test1")
         public String test1( @RequestBody @Validated({GroupA.class}) Student student){
             return student.getName();
         }
     }
     
     public class Student {
         @NotBlank(message = "不允许为空",groups = {GroupA.class})
         private String name ;
           @NotBlank(message = "不允许为空")
         private String age ;
     
         }
     
     ```

     @Validated({GroupA.class}) 表示只校验GroupA的校验项,上面的代码中 只会校验name字段,而不会校验age字段,如果需要校验没有group的字段,@Validated需要加上default.class

     ```
     import javax.validation.groups.Default;
     @Controller
     @Validated
     @RestController
     public class TestController {
         @PostMapping("/test1")
         public String test1( @RequestBody @Validated({GroupA.class, Default.class}) Student student){
     
             return student.getName();
         }
     }
     ```

     ​		这样就会校验GroupA和没有Group分组的校验项

##### 嵌套和分组组合

```
 @PostMapping("/test1")
    public String test1( @RequestBody @Validated({GroupA.class, GroupB.class}) Student student){

        return student.getName();
    }
    
    
    public class Student {

    @NotBlank(message = "不允许为空",groups = {GroupA.class})
    private String name ;
    @NotBlank(message = "不允许为空")
    private String age ;

    @NotEmpty(message = "不允许为空1")
    @Valid
    private List<Score> scoreList;
}
public class Score {
    @NotBlank(message = "不允许为空2",groups = {GroupA.class})
    public String name ;
    @NotBlank(message = "不允许为空2",groups = {GroupB.class})
    public String value ;
}

请求参数 
{
    "name": "1",
    "age": "",
    "scoreList": [{
        "name": "",
        "value": "1"
    }]
}

校验结果：
不允许为空2

```

##### 自定义校验

   自定义校验的步骤 

 1. 定义校验的注解

 2. 实现ConstraintValidator注解

    ```
    @Documented
    @Target({ElementType.METHOD,ElementType.FIELD,ElementType.PARAMETER,ElementType.CONSTRUCTOR})
    @Retention(RetentionPolicy.RUNTIME)
    // 指定被哪些校验器校验
    @Constraint(validatedBy = {MustInIntValidator.class})
    public @interface MustInInt {
    
        int[] value();
        String message() default "值一定要在给定的范围中";
        Class<?>[] groups() default  {};
        // 暂时不清楚作用
        Class<? extends Payload>[] payload() default {};
    }
    
    
    // 实现ConstraintValidator接口, Integer表示只能校验Integer参数
    public class MustInIntValidator  implements ConstraintValidator<MustInInt,Integer> {
        private int[] value ;
        @Override
        public void initialize(MustInInt mustInInt) {
            int[] value = mustInInt.value();
        }
    
        @Override
        public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) {
            return Arrays.asList(value).contains(integer);
    
        }
    }
    
      @MustInInt({1,2,3,4,5})
        private  Integer age ;
        
        
        
    
    ```

    

##### 编程式校验

去掉@Validated注解,

```
@Autowired
private Validator validator ;
@PostMapping("/test1")
public String test1( @RequestBody  Student student){
	//  validator.validate(待校验的对象,校验分组)
    Set<ConstraintViolation<Student>> validate = validator.validate(student, Default.class);
    // 校验通过 validate会是空
    if (validate.isEmpty()){

    }else{
    // 校验不通过
        for (ConstraintViolation<Student> studentConstraintViolation : validate) {
            System.out.println(studentConstraintViolation.getMessage());
        }
    }
    return student.getName();
}
```

##### **校验模式**

​		校验模式分为两组 

​			1.普通模式,每一个校验项都会校验

​			2.快速失败模式，只要有一个验证失败,就会停止校验			

```
@Configuration
public class ValidateStrategyConf {
    @Bean
    public Validator validator() {
        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
                .configure()
                .failFast( true )
                .buildValidatorFactory();
        Validator validator = validatorFactory.getValidator();
        return validator;
    }
}
```

#####  valid和validated的区别

@Validated 支持分组 不支持嵌套  Springboot

@Valid 支持嵌套 不支持分组   JSR303

##### 统一异常处理

```

@RestControllerAdvice
public class ExceptionHandle {
    @ExceptionHandler({BindException.class})
    public String bindExceptionHandel(BindException exception){
     
        return exception.getAllErrors().get(0).getDefaultMessage();
    }
    @ExceptionHandler({MethodArgumentNotValidException.class})
    public String m(MethodArgumentNotValidException exception){
       
        return exception.getAllErrors().get(0).getDefaultMessage();
    }
    @ExceptionHandler({ConstraintViolationException.class})
    public String m2(ConstraintViolationException e){
    
        return  e.getConstraintViolations().stream().findFirst().get().getMessage();
    }
}
```

BindException 异常

```
@Controller
@Validated
public class TestController {
    

    @PostMapping("/test1")
    public String test1( @Valid Student student){

        return student.getName();
    }  
    抛出BindException  用的是Valid注解校验,同时controller类上要加上@Validated注解
```

ConstraintViolationException 异常

```
@Controller
@Validated
public class TestController {
    @PostMapping("/test1")
    public String test1( @Valid Student student,BindingResult bindingResult){
        return student.getName();
    }
}
加上BindingResult之后就变成ConstraintViolationException异常



或者对单个参数而不是vo校验
@Controller
@Validated
public class TestController {


    @GetMapping("/test2")
    public String test2(@Max(value = 20,message = "最大值20") Integer age,@Max(value = 50,message = "最大值50") Integer age2){
        return age.toString();
    }
}



```

MethodArgumentNotValidException异常

```
@Controller
public class TestController {
    @PostMapping("/test1")
    public String test1( @RequestBody @Validated Student student){

        return student.getName();
    }
}

需要加上@RequestBody 并且去掉BindingResult  否则就404
```

参考资料

1. https://zhuanlan.zhihu.com/p/344039808#:~:text=SpringBoot%E7%9A%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%8F%AF%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%20%E5%88%9B%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AECheckOut%EF%BC%8C0%EF%BC%9A%20%3Cdependency%3E,%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%20%3CartifactId%3Espring-boot-starter%3C%2FartifactId%3E%20%3C%2Fdependency%3E
2. https://juejin.cn/post/7141260142758068237#heading-12