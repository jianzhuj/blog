上一篇中提到了Class.forName() ,这种加载类的方法,这次介绍另一种加载类的方式 ClassLoader.loadClass()

ClassLoader 加载过程如下

	1. findLoadedClass(） 判断是否加载过这个类
	1.  如果有父加载器，就先交给父加载器加载parent.loadClass  如果没有父加载器,就交给BootstrapClassLoader加载
	1. 如果父加载器没有办法加载,就尝试自己加载findClass ，findClass会直接抛异常，是需要子类去自己实现的

```
  protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

```

​	2,3两步就是双亲委派模型去加载类，而Class.forName()是用调用者的类加载器或者传入的指定类加载器去加载。

​	ClassLoader.loadClass过程主要设置到三个方法

   1. loadClass   加载类的调用入口,定义了用双亲委派模型去加载,可以重写去破坏双亲委派模型

   2.  findClass  如果父加载器都无法加载，就会调用自身的findClass去加载类,默认抛出异常,需要子类重写

   3.  defineClass  在findClass中调用,用来将字节码转化成class对象,在findClass中调用defineClass

       在自定义类加载的时候,通常需要重写findClass方法。

自定义类加载器

```
package com.ekko;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @author ekko
 */
public class MyClassLoader extends  ClassLoader{
    // 定义要加载的路径 即 加载 path路径下的#{name}.class
    private String path ;

    // 指定父加载器和能加载的路径
    public MyClassLoader(ClassLoader parent, String path) {
        super(parent);
        this.path = path;
    }

    // 比如要加载一个com.ekko.HelloWord的类
    // 重写逻辑
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String replace = name.replace('.', File.separatorChar);
        // 把.class文件读成字节数,传给defineClass
        try {
            FileInputStream fileInputStream = new FileInputStream(new File(path + File.separator + replace + ".class"));
            byte[] bytes = new byte[fileInputStream.available()];
            fileInputStream.read(bytes);
            return  defineClass(name,bytes,0,bytes.length);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }

    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
        //parent加载器传null,如果是传ApplicationClassLoader,会先被ApplicationClassLoader加载。
        //路径传当前路径
        MyClassLoader myClassLoader = new MyClassLoader(null, ".");
        Class<?> helloWord = myClassLoader.loadClass("com.ekko.HelloWord");
        Method hello = helloWord.getMethod("hello", null);
        String invoke = (String)hello.invoke(helloWord.newInstance(), null);
        System.out.println(invoke);
    }
}



package com.ekko;

public class HelloWord {
    public HelloWord() {
    }

    public String hello() {
        return "helloword";
    }
}

```

核心逻辑就是重写findClass,将指定路径下的某个class文件读取成字节数组,然后由defineClass加载成class对象



ClassLoader相当于类的命名空间,起到了类隔离的作用,位于同一个ClassLoader中的类名是唯一的,不同的ClassLoader可以拥有相同的类。每一个Class对象都有一个字段classLoader来表示它是被哪个ClassLoader加载出来的



自定义类加载的使用场景

1. 源码加密

   将class文件通过加密之后,通过自定义的类加载器去解密,然后加载类

   

2. 热部署

   原理就是监听文件的变化,然后清除相关引用，然后销毁自定义的类加载器，等待gc之后,创建新的类加载器来加载更新后的文件

3. 类隔离  

   Tomcat内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。



参考链接

https://developer.aliyun.com/article/828000

https://zhuanlan.zhihu.com/p/51374915